
## USR-001: 사용자 회원가입 및 로그인

본 기능은 사용자가 서비스를 이용하기 위해 계정을 생성하고, 생성된 계정을 통해 인증을 수행하는 핵심적인 역할을 담당합니다. 모든 생성 데이터는 사용자 계정에 귀속되므로, 안정적인 인증 처리가 필수적입니다.

### 1\. 사용자 시나리오 (User Scenario)

* **회원가입:**
    1.  랜딩 페이지(`PGE-001`)에서 '무료로 시작하기' 버튼을 클릭하여 회원가입 페이지로 이동한다.
    2.  이메일 주소와 비밀번호를 정해진 양식에 맞게 입력한다.
    3.  '가입하기' 버튼을 클릭하자, 유효성 검사를 통과하고 계정이 성공적으로 생성되었다는 안내와 함께 로그인 페이지로 이동하거나 자동으로 로그인된다.
* **로그인:**
    1.  회원가입 후 또는 기존 사용자가 로그인 페이지에 접속한다.
    2.  가입 시 사용했던 이메일 주소와 비밀번호를 입력한다.
    3.  '로그인' 버튼을 클릭하자, 정보가 유효하면 성공적으로 로그인되어 채용 프로젝트를 관리할 수 있는 대시보드 페이지로 이동한다.

### 2\. API 명세 (API Specification)

#### 2.1. 회원가입 (Sign Up)

* **Endpoint:** `POST /auth/signup`
* **Description:** 새로운 사용자 계정을 생성합니다.
* **Request:**
    * **Headers:**
      ```json
      {
        "Content-Type": "application/json"
      }
      ```
    * **Body:**
      ```json
      {
        "email": "user@example.com",
        "password": "Password123!"
      }
      ```
* **Response:**
    * **Success (201 Created):**
      ```json
      {
        "message": "User successfully created."
      }
      ```
    * **Error (400 Bad Request):** 입력 값 유효성 검사 실패 시
      ```json
      {
        "statusCode": 400,
        "message": [
          "email must be an email",
          "password must be longer than or equal to 8 characters"
        ],
        "error": "Bad Request"
      }
      ```
    * **Error (409 Conflict):** 이미 존재하는 이메일로 가입 시도 시
      ```json
      {
        "statusCode": 409,
        "message": "User with this email already exists.",
        "error": "Conflict"
      }
      ```

#### 2.2. 로그인 (Sign In)

* **Endpoint:** `POST /auth/login`
* **Description:** 사용자를 인증하고 API 접근 토큰(JWT)을 발급합니다.
* **Request:**
    * **Headers:**
      ```json
      {
        "Content-Type": "application/json"
      }
      ```
    * **Body:**
      ```json
      {
        "email": "user@example.com",
        "password": "Password123!"
      }
      ```
* **Response:**
    * **Success (200 OK):**
      ```json
      {
        "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
      }
      ```
    * **Error (401 Unauthorized):** 이메일 또는 비밀번호가 일치하지 않을 때
      ```json
      {
        "statusCode": 401,
        "message": "Invalid credentials.",
        "error": "Unauthorized"
      }
      ```

### 3\. 핵심 비즈니스 로직 (Core Business Logic)

#### **회원가입 로직 (`auth.controller.ts` -\> `user.service.ts`)**

1.  **요청 수신 및 유효성 검사 (DTO Validation):**
    * `email`은 유효한 이메일 형식이어야 합니다.
    * `password`는 최소 8자 이상, 영문, 숫자, 특수문자를 포함하는 등의 규칙을 적용합니다. (NestJS의 `class-validator` 사용)
2.  **이메일 중복 확인:**
    * `Prisma Client`를 사용하여 `User` 테이블에서 요청된 `email`과 일치하는 레코드가 있는지 조회합니다.
    * `findUnique({ where: { email } })`
    * 만약 사용자가 존재한다면, `409 Conflict` 예외를 발생시킵니다.
3.  **비밀번호 해싱:**
    * `bcrypt` 라이브러리를 사용하여 사용자의 비밀번호를 안전하게 해시(hash) 처리합니다. 절대로 평문 비밀번호를 데이터베이스에 저장해서는 안 됩니다.
    * `const hashedPassword = await bcrypt.hash(password, 10);` (salt round는 10\~12)
4.  **사용자 생성:**
    * 해시된 비밀번호와 이메일을 사용하여 `User` 테이블에 새로운 레코드를 생성합니다.
    * `prisma.user.create({ data: { email, password: hashedPassword } })`
5.  **성공 응답 반환:**
    * `201 Created` 상태 코드와 함께 성공 메시지를 반환합니다.

#### **로그인 로직 (`auth.controller.ts` -\> `user.service.ts`)**

1.  **요청 수신 및 유효성 검사 (DTO Validation):**
    * `email`과 `password` 필드가 비어있지 않은지 확인합니다.
2.  **사용자 조회:**
    * `Prisma Client`를 사용하여 `email`로 사용자를 조회합니다.
    * 사용자가 존재하지 않을 경우, `401 Unauthorized` 예외를 발생시킵니다. (보안을 위해 "존재하지 않는 이메일"이라는 구체적인 메시지 대신 "자격 증명이 유효하지 않다"로 통일)
3.  **비밀번호 검증:**
    * 조회된 사용자의 해시된 비밀번호와 요청으로 받은 평문 비밀번호를 `bcrypt.compare()` 함수를 사용하여 비교합니다.
    * 비밀번호가 일치하지 않으면, `401 Unauthorized` 예외를 발생시킵니다.
4.  **JWT 생성:**
    * 비밀번호가 일치하면, JWT(JSON Web Token)를 생성합니다.
    * Payload에는 사용자를 식별할 수 있는 정보(e.g., `userId`)를 포함시킵니다.
    * JWT Secret Key는 반드시 `.env` 파일에서 관리해야 합니다.
5.  **토큰 응답 반환:**
    * `200 OK` 상태 코드와 함께 생성된 `accessToken`을 반환합니다. 이 토큰은 클라이언트 측에서 저장하여 이후 API 요청 시 `Authorization` 헤더에 `Bearer` 토큰으로 사용됩니다.

### 4\. 데이터 모델 (Data Model)

* **ORM:** Prisma
* **Database:** PostgreSQL
* **Model (`schema.prisma`):**

<!-- end list -->

```prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") // .env 파일에서 관리
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // 사용자가 생성한 채용 프로젝트와의 관계 설정 (향후 PRJ-001 구현 시)
  // jobPostings JobPosting[]
}
```

### 5\. 예외 처리 (Exception Handling)

NestJS의 내장 예외 필터(`Exception Filters`)를 활용하여 일관된 오류 응답 형식을 유지합니다.

| HTTP Status | 발생 상황 (Scenario) | 처리 주체 | 응답 메시지 |
| :--- | :--- | :--- | :--- |
| **400 Bad Request** | `email` 형식이 아니거나 `password`가 너무 짧은 등 DTO 유효성 검사 실패. | `ValidationPipe` | `"email must be an email"` |
| **401 Unauthorized**| 로그인 시 `email`이 존재하지 않거나, `password`가 틀렸을 경우. | `user.service.ts` | `"Invalid credentials."` |
| **409 Conflict** | 회원가입 시 이미 존재하는 `email`로 요청한 경우. | `user.service.ts` | `"User with this email already exists."` |
| **500 Internal Server Error** | 데이터베이스 연결 실패 등 예측하지 못한 서버 내부 오류 발생. | `NestJS` 기본 | `"Internal server error"` |