
## USR-001: 사용자 회원가입 및 로그인

본 기능은 사용자가 이메일 및 전화번호 인증을 통해 계정을 생성하고, 생성된 계정으로 서비스를 이용할 수 있도록 하는 핵심 인증 절차입니다. 모든 사용자 데이터는 이중으로 검증된 계정에 귀속됩니다.
### 1\. 사용자 시나리오 (User Scenario)

* **회원가입:**
    1.  랜딩 페이지에서 '무료로 시작하기' 버튼을 클릭하여 회원가입 페이지로 이동한다.
    2. '개인정보보호정책에 동의합니다 (필수)' 체크박스를 클릭한다. (이 항목을 동의하지 않으면 가입 버튼이 활성화되지 않는다.)
    3. '(선택) 마케팅 및 이벤트 정보 수신에 동의합니다' 체크박스를 필요에 따라 선택한다.
    4. 이메일 주소, 비밀번호, **전화번호**를 입력하고 '인증번호 받기' 버튼을 클릭한다.
    5. 입력한 이메일과 휴대폰으로 각각 인증번호가 발송되었다는 안내를 확인한다.
    6. 이메일과 문자 메시지로 수신한 인증번호를 화면의 해당 필드에 정확히 입력한다.
    7. '가입 완료' 버튼을 클릭하자, 모든 정보가 유효하면 계정이 성공적으로 생성되고 로그인 페이지로 이동하거나 자동으로 로그인된다.
* **로그인:**
    1.  로그인 페이지에서 가입 시 사용했던 이메일 주소와 비밀번호를 입력한다.
    2.  '로그인' 버튼을 클릭하면 성공적으로 로그인되어 대시보드 페이지로 이동한다.

### 2\. API 명세 (API Specification)

#### 2.1. 인증번호 발송 (Send Verification Code)

* **Endpoint:** `POST /auth/send-verification`
* **Description:** 이메일 또는 전화번호로 인증번호를 발송합니다.
* **Request:**
    * **Body:**
      ```json
      {
        "type": "EMAIL", // "EMAIL" or "SMS"
        "recipient": "user@example.com" // 이메일 주소 또는 전화번호 ('-' 제외)
      }
      ```
* **Response:**
    * **Success (200 OK):**
      ```json
      {
        "message": "Verification code sent successfully."
      }
      ```
    * **Error (400 Bad Request):** 이메일/전화번호 형식이 올바르지 않을 때
      ```json
      {
        "statusCode": 400,
        "message": "Invalid recipient format.",
        "error": "Bad Request"
      }
      ```
    * **Error (429 Too Many Requests):** 단기간에 너무 많은 요청을 보냈을 때
      ```json
      {
        "statusCode": 429,
        "message": "Too many requests. Please try again later.",
        "error": "Too Many Requests"
      }
      ```

#### 2.2. 인증번호 확인 (Verify Code)

* **Endpoint:** `POST /auth/verify-code`
* **Description:** 사용자가 입력한 인증번호가 유효한지 확인하고, 유효할 경우 임시 인증 토큰을 발급합니다.
* **Request:**
    * **Body:**
      ```json
      {
        "type": "EMAIL", // "EMAIL" or "SMS"
        "recipient": "user@example.com",
        "code": "123456"
      }
      ```
* **Response:**
    * **Success (200 OK):**
      ```json
      {
        "message": "Verification successful.",
        "verificationToken": "temp-jwt-for-email-verification.etc..."
      }
      ```
    * **Error (400 Bad Request):** 코드가 일치하지 않거나 만료되었을 때
      ```json
      {
        "statusCode": 400,
        "message": "Invalid or expired verification code.",
        "error": "Bad Request"
      }
      ```

#### 2.3. 최종 회원가입 (Sign Up)

* **Endpoint:** `POST /auth/signup`
* **Description:** 모든 인증이 완료된 사용자의 계정을 최종적으로 생성합니다.
* **Request:**
    * **Body:**
      ```json
      {
       "email": "user@example.com",
       "password": "Password123!",
       "phoneNumber": "01012345678",
       "emailVerificationToken": "temp-jwt-for-email-verification.etc...",
       "phoneVerificationToken": "temp-jwt-for-phone-verification.etc...",
       "termsAgreement": true, // 개인정보보호정책 동의 (필수)
       "marketingAgreement": false // 마케팅 정보 수신 동의 (선택)
      }
      ```
* **Response:**
    * **Success (201 Created):**
      ```json
      {
        "message": "User successfully created.",
        "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
      }
      ```
   * **Error (400 Bad Request):** 필수 동의 항목을 체크하지 않았을 때
      ```json
      {
        "statusCode": 400,
        "message": "Agreement to the terms and privacy policy is required.",
        "error": "Bad Request"
      }
      ```
    * **Error (401 Unauthorized):** 인증 토큰이 유효하지 않거나 누락되었을 때
      ```json
      {
        "statusCode": 401,
        "message": "Valid verification token is required.",
        "error": "Unauthorized"
      }
      ```
    * **Error (409 Conflict):** 이미 가입된 이메일 또는 전화번호일 때
      ```json
      {
        "statusCode": 409,
        "message": "User with this email or phone number already exists.",
        "error": "Conflict"
      }
      ```

#### 2.4. 로그인 (Sign In)

* **Endpoint:** `POST /auth/login`
* **Description:** 사용자를 인증하고 API 접근 토큰(JWT)을 발급합니다.
* **Request:**
    * **Headers:**
      ```json
      {
        "Content-Type": "application/json"
      }
      ```
    * **Body:**
      ```json
      {
        "email": "user@example.com",
        "password": "Password123!"
      }
      ```
* **Response:**
    * **Success (200 OK):**
      ```json
      {
        "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
      }
      ```
    * **Error (401 Unauthorized):** 이메일 또는 비밀번호가 일치하지 않을 때
      ```json
      {
        "statusCode": 401,
        "message": "Invalid credentials.",
        "error": "Unauthorized"
      }
      ```

### 3\. 핵심 비즈니스 로직 (Core Business Logic)

#### **인증 및 회원가입 로직 (`auth.controller.ts` -\> `user.service.ts`)**

1.  **인증번호 생성 및 발송:**
    * `/auth/send-verification` 요청 시, 6자리 난수를 생성합니다.
    * 요청 `type`에 따라 이메일(e.g., Nodemailer) 또는 SMS 발송 서비스(e.g., Twilio, NHN Cloud)를 호출합니다.
    * 생성된 인증번호와 수신자 정보, 만료 시간(e.g., 3분)을 `Verification` 테이블에 저장합니다.
2.  **인증번호 검증:**
    * `/auth/verify-code` 요청 시, `Verification` 테이블에서 수신자 정보와 코드가 일치하는지, 그리고 만료 시간이 지나지 않았는지 확인합니다.
    * 검증에 성공하면, 해당 인증이 완료되었음을 증명하는 단기 JWT(`verificationToken`)를 생성하여 응답으로 반환합니다. 이 토큰의 Payload에는 `recipient`와 `type`이 포함됩니다.
    * 검증에 사용된 인증번호는 즉시 DB에서 삭제하거나 '사용됨' 상태로 변경하여 재사용을 방지합니다.
3.  **최종 회원가입 처리:**
    * 인증 토큰 검증: emailVerificationToken과 phoneVerificationToken의 유효성을 검증합니다.
    * 필수 동의 항목 검증:
      * 요청 body의 termsAgreement 필드가 true인지 확인합니다.
      * 만약 false이거나 값이 없다면, 400 Bad Request 예외를 즉시 발생시킵니다.
    * 정보 중복 확인: 이메일과 전화번호가 User 테이블에 이미 존재하는지 확인합니다.
    * 비밀번호 해싱: bcrypt를 사용하여 비밀번호를 암호화합니다.
    * 사용자 생성: 모든 검증을 통과하면 User 테이블에 새로운 사용자를 생성합니다. 이때, termsAgreement와 marketingAgreement 값을 함께 저장하여 사용자의 동의 여부를 기록으로 남깁니다.
    * 로그인 토큰 발급: 사용자 생성이 성공적으로 완료되면, 즉시 해당 사용자의 정보(e.g., userId)를 기반으로 로그인 accessToken을 생성합니다.
    * 최종 응답 반환: 201 Created 상태 코드와 함께 생성된 accessToken을 응답 body에 포함하여 반환합니다.


### 4\. 데이터 모델 (Data Model)

* **ORM:** Prisma
* **Database:** PostgreSQL
* **Model (`schema.prisma`):**

<!-- end list -->

```prisma
// This is your Prisma schema.prisma file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") // .env 파일에서 관리
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String
  phoneNumber   String?   @unique // 전화번호 필드 추가, unique 제약조건
  emailVerified Boolean   @default(false) // 이메일 인증 여부
  phoneVerified Boolean   @default(false) // 전화번호 인증 여부
  
  // 동의 항목 필드 추가
  termsAgreedAt      DateTime? // 필수 동의는 동의한 시각을 저장하여 법적 증빙 강화
  marketingAgreement Boolean   @default(false) // 선택 동의는 boolean으로 관리
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // 사용자가 생성한 채용 프로젝트와의 관계 설정 (향후 PRJ-001 구현 시)
  // jobPostings JobPosting[]
}

// 인증번호 임시 저장을 위한 모델 추가
model Verification {
  id        String   @id @default(cuid())
  type      String   // "EMAIL" or "SMS"
  recipient String
  code      String
  expiresAt DateTime // 만료 시간

  @@index([recipient, type]) // 수신자와 타입으로 빠르게 조회하기 위한 인덱스
}
```
Note: 필수 동의 항목인 termsAgreement는 boolean 대신 동의한 시점을 기록하는 termsAgreedAt (DateTime) 필드로 관리하는 것이 법적 분쟁 발생 시 더 강력한 증거가 될 수 있습니다. 로직에서는 해당 필드에 new Date()를 저장합니다.

### 5\. 예외 처리 (Exception Handling)

| HTTP Status | 발생 상황 (Scenario) | 처리 주체 | 응답 메시지 |
| :--- | :--- | :--- | :--- |
| **400 Bad Request** | **필수 약관(`termsAgreement`)에 동의하지 않고 가입을 시도**할 때. | `user.service.ts` | `"Agreement to the terms and privacy policy is required."` |
| **400 Bad Request** | 인증번호가 틀리거나 만료된 경우. | `user.service.ts` | `"Invalid or expired verification code."` |
| **401 Unauthorized**| 최종 회원가입 시 `verificationToken`이 없거나 유효하지 않을 때. | `AuthGuard` | `"Valid verification token is required."` |
| **409 Conflict** | 이미 가입된 이메일 또는 전화번호로 가입을 시도할 때. | `user.service.ts` | `"User with this email or phone number already exists."` |
| **429 Too Many Requests**| 인증번호를 너무 자주 요청할 때. | (Rate Limiter) | `"Too many requests. Please try again later."` |