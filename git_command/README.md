## **Git 전체 명령어 요약**

Git의 모든 명령어를 기능별로 분류하고, 주요 명령어에 대한 상세 설명을 제공합니다.

***

### **구조적 분석**

* **Problem (문제)**: 사용자는 Git에서 사용할 수 있는 전체 명령어 목록과 그 기능에 대한 포괄적인 정보를 필요로 합니다.
* **Cause (원인)**: Git은 버전 관리 시스템으로, 다양한 상황에 대처하기 위한 수많은 명령어를 제공합니다. 모든 명령어를 기억하고 적재적소에 활용하기는 어렵습니다.
* **Solution (해결책)**: 명령어를 기능별(저장소 생성, 스냅샷, 브랜치 및 병합, 공유 및 업데이트 등)로 분류하여 체계적으로 정리하고, 각 명령어의 핵심 기능을 설명합니다.

***

### **Git 명령어 전체 목록**

Git 명령어는 크게 **기본 명령어**와 **고급 명령어**로 나눌 수 있으며, 기능에 따라 다음과 같이 분류할 수 있습니다.

#### **1. 저장소 생성 및 관리**

| 명령어 | 설명 |
| :--- | :--- |
| **`git init`** | 현재 디렉토리를 Git 저장소로 초기화합니다. `.git` 디렉토리가 생성됩니다. |
| **`git clone`** | 원격 저장소를 로컬 환경으로 복제합니다. |
| **`git config`** | Git의 설정을 확인하거나 변경합니다. (사용자 이름, 이메일 등) |

#### **2. 스냅샷 (Snapshot) 관련**

| 명령어 | 설명 |
| :--- | :--- |
| **`git add`** | 변경된 파일을 Staging Area(인덱스)에 추가합니다. |
| **`git commit`** | Staging Area에 있는 파일들을 로컬 저장소에 스냅샷으로 기록합니다. |
| **`git status`** | 현재 저장소의 상태(변경, 추적되지 않는 파일 등)를 확인합니다. |
| **`git diff`** | 마지막 커밋과 현재 작업 디렉토리 또는 Staging Area의 변경 내용을 비교합니다. |
| **`git log`** | 저장소의 커밋 히스토리를 시간순으로 보여줍니다. |
| **`git rm`** | 파일을 작업 디렉토리에서 삭제하고 Staging Area에서도 제거합니다. |
| **`git mv`** | 파일의 이름을 변경하거나 위치를 이동시킵니다. (`git rm` + `git add`와 유사) |
| **`git restore`** | 작업 디렉토리의 파일을 이전 상태로 복원합니다. |

#### **3. 브랜치 및 병합 (Branch & Merge)**

| 명령어 | 설명 |
| :--- | :--- |
| **`git branch`** | 브랜치 목록을 확인하거나, 새 브랜치를 생성/삭제합니다. |
| **`git checkout`** | 다른 브랜치로 전환하거나, 특정 커밋 시점의 파일로 복원합니다. |
| **`git switch`** | (최신 버전) 브랜치를 전환하는 데 특화된 명령어입니다. (`checkout`의 기능 분리) |
| **`git merge`** | 다른 브랜치의 변경 내용을 현재 브랜치로 병합합니다. |
| **`git rebase`** | 브랜치의 기반(base)을 다른 커밋 위로 변경하여 히스토리를 재정렬합니다. |
| **`git cherry-pick`** | 다른 브랜치에 있는 특정 커밋 하나만 현재 브랜치로 가져옵니다. |
| **`git tag`** | 특정 커밋에 읽기 쉬운 태그(예: v1.0)를 붙입니다. |



#### **4. 원격 저장소 공유 및 업데이트**

| 명령어 | 설명 |
| :--- | :--- |
| **`git remote`** | 연결된 원격 저장소의 목록을 확인하거나, 추가/삭제합니다. |
| **`git fetch`** | 원격 저장소의 최신 변경 내용을 로컬로 가져오지만, 병합은 하지 않습니다. |
| **`git pull`** | 원격 저장소의 최신 변경 내용을 가져와 현재 브랜치와 병합합니다. (`fetch` + `merge`) |
| **`git push`** | 로컬 저장소의 커밋을 원격 저장소로 업로드합니다. |

#### **5. 고급 및 기타 명령어**

| 명령어 | 설명 |
| :--- | :--- |
| **`git stash`** | 아직 커밋하지 않은 변경 내용을 임시로 저장합니다. |
| **`git reset`** | 지정한 커밋으로 HEAD를 이동시키며, Staging Area나 작업 디렉토리를 변경할 수 있습니다. |
| **`git revert`** | 특정 커밋의 변경 내용을 되돌리는 새로운 커밋을 생성합니다. (히스토리 유지) |
| **`git blame`** | 파일의 각 줄이 어떤 커밋에 의해 마지막으로 수정되었는지 보여줍니다. |
| **`git bisect`** | 이진 탐색을 통해 버그를 발생시킨 커밋을 자동으로 찾아줍니다. |
| **`git reflog`** | HEAD가 변경된 모든 기록을 보여주어, 삭제된 커밋이나 브랜치를 복구할 때 유용합니다. |
| **`git submodule`** | Git 저장소 안에 다른 Git 저장소를 포함시킬 때 사용합니다. |

***

### **실행 우선순위 제안**

1.  **필수 학습 (Priority 1)**: `init`, `clone`, `add`, `commit`, `status`, `log`, `branch`, `checkout`, `push`, `pull`
    * **판단 기준**: Git을 사용한 기본적인 버전 관리 및 협업을 위해 반드시 알아야 하는 핵심 명령어입니다.
2.  **중급 활용 (Priority 2)**: `diff`, `merge`, `rebase`, `fetch`, `remote`, `reset`
    * **판단 기준**: 브랜치를 활용한 병렬 작업 및 충돌 해결, 원격 저장소와의 고급 상호작용에 필요합니다.
3.  **고급 및 특수 목적 (Priority 3)**: `stash`, `revert`, `cherry-pick`, `tag`, `blame`
    * **판단 기준**: 특정 문제 해결이나 효율적인 워크플로우 관리를 위해 필요한 심화 명령어입니다.

***

## **Git Flow와 Git Hooks: 개념 및 활용법 요약**

Git Flow는 **브랜치 관리 전략**이며, Git Hooks는 특정 Git 이벤트에 연동하여 **스크립트를 자동 실행**하는 기능입니다. 이 두 가지를 활용하면 팀의 개발 워크플로우를 체계적으로 관리하고 코드 품질을 일관성 있게 유지할 수 있습니다.

-----

### **구조적 분석**

* **Problem (문제)**: Git을 사용한 협업 시, 브랜치 관리 규칙이 없으면 프로젝트 히스토리가 복잡해지고, 코드 품질을 수동으로 검증하는 과정에서 실수가 발생할 수 있습니다.
* **Cause (원인)**: 여러 개발자가 동시에 다양한 기능을 개발하고 수정하는 과정에서 일관된 규칙과 자동화된 검증 절차의 부재는 혼란을 야기합니다.
* **Solution (해결책)**: Git Flow 모델을 도입하여 브랜치 사용 규칙을 명확히 하고, Git Hooks를 이용해 커밋이나 푸시 같은 특정 단계에서 코드 스타일 검사, 테스트 실행 등을 자동화하여 워크플로우를 개선합니다.

-----

### **1. Git Flow: 체계적인 브랜치 관리 전략**

Git Flow는 Vincent Driessen이 제안한 브랜치 관리 모델로, 프로젝트의 기능 개발, 출시, 긴급 수정 등을 체계적으로 관리하기 위해 5가지 종류의 브랜치를 사용합니다. 이는 대규모 프로젝트나 정기적인 배포 주기를 가진 프로젝트에 적합합니다.

#### **주요 브랜치와 역할**

| 브랜치 종류 | 역할 및 특징 | 수명 |
| :--- | :--- | :--- |
| **`master` (or `main`)** | **제품 출시 버전**을 관리하는 가장 안정적인 브랜치입니다. 배포 가능한 상태의 코드만 포함하며, 각 커밋은 버전 태그(`v1.0`, `v1.1`)를 가집니다. | 영구 |
| **`develop`** | **다음 버전 개발**을 위한 통합 브랜치입니다. 모든 기능 개발이 완료되고 QA를 통과할 준비가 된 코드들이 이곳으로 병합됩니다. | 영구 |
| **`feature`** | **단일 기능 개발**을 위한 브랜치입니다. `develop` 브랜치에서 분기하며, 개발 완료 후 다시 `develop` 브랜치로 병합됩니다. (예: `feature/user-login`) | 단기 |
| **`release`** | **새 버전 출시를 준비**하기 위한 브랜치입니다. `develop` 브랜치에서 분기하며, 배포 전 최종 버그 수정, 문서 작업 등만 수행합니다. 완료 후 `master`와 `develop`에 모두 병합됩니다. (예: `release/v1.0`) | 단기 |
| **`hotfix`** | **출시된 버전의 긴급 버그**를 수정하기 위한 브랜치입니다. `master` 브랜치에서 직접 분기하며, 수정 완료 후 `master`와 `develop`에 모두 병합됩니다. (예: `hotfix/v1.0.1`) | 단기 |

#### **워크플로우 요약**

1.  **기능 개발**: `develop`에서 `feature` 브랜치를 생성하여 작업을 시작합니다.
2.  **기능 통합**: 개발이 완료되면 `feature` 브랜치를 `develop`에 병합(Merge)합니다.
3.  **릴리스 준비**: 배포 시점이 되면 `develop`에서 `release` 브랜치를 생성하여 QA 및 최종 점검을 진행합니다.
4.  **배포**: `release` 브랜치를 `master`와 `develop`에 병합하고, `master` 브랜치에 버전 태그를 생성하여 배포합니다.
5.  **긴급 수정**: `master`에서 `hotfix` 브랜치를 생성하여 버그를 수정하고, `master`와 `develop`에 병합합니다.

-----

### **2. Git Hooks: 특정 이벤트 자동화**

Git Hooks는 `.git/hooks` 디렉토리에 위치한 실행 가능한 스크립트로, **커밋, 푸시, 병합 등 특정 Git 이벤트가 발생했을 때 자동으로 실행**됩니다. 이를 통해 팀의 규칙을 강제하거나 반복적인 작업을 자동화할 수 있습니다.

#### **주요 Hooks와 활용 예시**

Hooks는 크게 \*\*클라이언트 측(Client-Side)\*\*과 \*\*서버 측(Server-Side)\*\*으로 나뉩니다.

| 종류 | Hook 이름 | 실행 시점 | 주요 활용 예시 |
| :--- | :--- | :--- | :--- |
| **클라이언트 측** | `pre-commit` | `git commit` 명령 실행 전 | • 코드 스타일 가이드 준수 여부 검사 (Linting)<br>• 코드 포맷팅 자동 적용 (Formatting)<br>• 디버깅 코드(`console.log` 등) 포함 여부 확인 |
| | `prepare-commit-msg` | 커밋 메시지 에디터 실행 전 | • 커밋 메시지 템플릿 자동 생성 (이슈 번호 등) |
| | `commit-msg` | 커밋 메시지 저장 후, 최종 커밋 전 | • 커밋 메시지가 정해진 규칙(예: `feat:`, `fix:`)을 따르는지 검증 |
| | `pre-push` | `git push` 명령 실행 전 | • 로컬 테스트 코드 실행 및 통과 여부 확인<br>• `master` 브랜치에 직접 푸시하는 것을 방지 |
| **서버 측**| `pre-receive` | 원격 저장소에 푸시된 커밋을 받기 전 | • 모든 커밋이 특정 정책(GPG 서명 등)을 만족하는지 검사<br>• 브랜치 강제 푸시(force push) 방지 |
| | `post-receive` | 푸시가 완료된 후 | • 지속적 통합(CI) 서버에 빌드 요청<br>• 팀원들에게 이메일 또는 슬랙 알림 발송 |

#### **설정 방법**

기본적으로 `.git/hooks` 디렉토리에는 `.sample` 확장자를 가진 예제 파일들이 있습니다. 이 파일에서 `.sample` 확장자를 제거하고 실행 권한을 부여하면 해당 Hook이 활성화됩니다. 팀 전체에 동일한 Hook을 적용하기 위해서는 **Husky**와 같은 라이브러리를 사용하여 설정을 프로젝트 레벨에서 관리하는 것이 일반적입니다.

-----

### **실행 우선순위 제안**

1.  **Git Flow 이해 (Priority 1)**: 팀 프로젝트 시작 시, 브랜치 전략을 먼저 정의하는 것이 중요합니다. 프로젝트의 규모와 배포 주기를 고려하여 Git Flow 또는 Github Flow와 같은 모델을 선택하고 팀원 전체가 숙지해야 합니다.
2.  **핵심 Git Hooks 도입 (Priority 2)**: 일관된 코드 품질 유지를 위해 `pre-commit` (코드 스타일 검사)과 `commit-msg` (커밋 메시지 규칙 검사) Hook을 우선적으로 도입하는 것을 권장합니다.
3.  **고급 Hooks 및 CI 연동 (Priority 3)**: 워크플로우가 안정되면 `pre-push` (테스트 자동화)나 `post-receive` (CI/CD 파이프라인 연동) 같은 고급 Hook을 도입하여 자동화 수준을 높일 수 있습니다.

-----

[Git Flow에 대한 자세한 설명](https://www.youtube.com/watch?v=w2F8O9J1keM)
http://googleusercontent.com/youtube_content/1